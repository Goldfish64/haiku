/*
 * Copyright 2026 John Davis
 * All rights reserved. Distributed under the terms of the MIT License.
 */
#ifndef _HYPERV_REG_H_
#define _HYPERV_REG_H_

// Page sizes for Hyper-V are 4KB on all platforms
#define HV_PAGE_SIZE			4096
#define HV_PAGE_SHIFT			12
#define HV_PAGE_ALIGN(x) 		(((x) + (HV_PAGE_SIZE - 1)) & ~(HV_PAGE_SIZE - 1))
#define HV_BYTES_TO_PAGES(x)	(HV_PAGE_ALIGN(x) >> HV_PAGE_SHIFT)

// CPUID leaves
#define IA32_CPUID_LEAF_HYPERVISOR				0x40000000
#define IA32_CPUID_LEAF_HV_INT_ID				0x40000001
#define IA32_CPUID_LEAF_HV_SYS_ID				0x40000002
#define IA32_CPUID_LEAF_HV_FEAT_ID				0x40000003
#define IA32_CPUID_LEAF_HV_IMP_RECOMMENDS		0x40000004
#define IA32_CPUID_LEAF_HV_IMP_LIMITS			0x40000005
#define IA32_CPUID_LEAF_HV_IMP_FEATURES			0x40000006

// Hyper-V signature "Hv#1"
#define HV_CPUID_INTERFACE_ID					0x31237648

// MSR registers
#define IA32_MSR_HV_GUEST_OS_ID					0x40000000
#define IA32_MSR_HV_HYPERCALL					0x40000001
#define IA32_MSR_HV_VP_INDEX					0x40000002
#define IA32_MSR_HV_RESET						0x40000003
#define IA32_MSR_HV_VP_RUNTIME					0x40000010

#define IA32_MSR_HV_TIME_REF_COUNT				0x40000020
#define IA32_MSR_HV_REFERENCE_TSC				0x40000021
#define IA32_MSR_HV_TSC_FREQUENCY				0x40000022
#define IA32_MSR_HV_APIC_FREQUENCY				0x40000023

#define IA32_MSR_HV_EOI							0x40000070
#define IA32_MSR_HV_ICR							0x40000071
#define IA32_MSR_HV_TPR							0x40000072
#define IA32_MSR_HV_APIC_ASSIST_PAGE			0x40000073

#define IA32_MSR_HV_SCONTROL					0x40000080
#define IA32_MSR_HV_SVERSION					0x40000081
#define IA32_MSR_HV_SIEFP						0x40000082
#define IA32_MSR_HV_SIMP						0x40000083
#define IA32_MSR_HV_EOM							0x40000084

#define IA32_MSR_HV_SINT0						0x40000090
#define IA32_MSR_HV_STIMER0_CONFIG				0x400000B0
#define IA32_MSR_HV_STIMER0_COUNT				0x400000B1

#define IA32_MSR_HV_GUEST_IDLE					0x400000f0

// MSR guest ID bits
#define IA32_MSR_HV_GUEST_OS_ID_BUILD_MASK		0x000000000000FFFFULL
#define IA32_MSR_HV_GUEST_OS_ID_VERSION_MASK	0x0000FFFFFFFF0000ULL
#define IA32_MSR_HV_GUEST_OS_ID_VERSION_SHIFT	16
#define IA32_MSR_HV_GUEST_OS_ID_OSID_MASK		0x00FF000000000000ULL
#define IA32_MSR_HV_GUEST_OS_ID_OSID_SHIFT		48
#define IA32_MSR_HV_GUEST_OS_ID_OSTYPE_MASK		0x7F00000000000000ULL
#define IA32_MSR_HV_GUEST_OS_ID_OSTYPE_SHIFT	56
#define IA32_MSR_HV_GUEST_OS_ID_OPEN_SOURCE		0x8000000000000000ULL
// Report as FreeBSD, can optionally request a new OS type for Haiku
#define IA32_MSR_HV_GUEST_OS_ID_OSTYPE_HAIKU \
	((0x02ULL << IA32_MSR_HV_GUEST_OS_ID_OSTYPE_SHIFT) \
		| IA32_MSR_HV_GUEST_OS_ID_OPEN_SOURCE)

// MSR hypercall bits
#define IA32_MSR_HV_HYPERCALL_ENABLE			0x0001ULL
#define IA32_MSR_HV_HYPERCALL_RSVD_MASK			0x0FFEULL
#define IA32_MSR_HV_HYPERCALL_PAGE_SHIFT		12

// MSR SynIC control bits
#define IA32_MSR_HV_SCONTROL_ENABLE				0x0001ULL
#define IA32_MSR_HV_SCONTROL_RSVD_MASK			0xFFFFFFFFFFFFFFFEULL

// MSR SIEFP bits
#define IA32_MSR_HV_SIEFP_ENABLE				0x0001ULL
#define IA32_MSR_HV_SIEFP_RSVD_MASK				0x0FFEULL
#define IA32_MSR_HV_SIEFP_PAGE_SHIFT			12
#define IA32_MSR_HV_SIEFP_PAGE_MASK				(~0ULL << IA32_MSR_HV_SIEFP_PAGE_SHIFT)

// MSR SIMP bits
#define IA32_MSR_HV_SIMP_ENABLE					0x0001ULL
#define IA32_MSR_HV_SIMP_RSVD_MASK				0x0FFEULL
#define IA32_MSR_HV_SIMP_PAGE_SHIFT				12
#define IA32_MSR_HV_SIMP_PAGE_MASK				(~0ULL << IA32_MSR_HV_SIMP_PAGE_SHIFT)

// MSR SINT bits
#define IA32_MSR_HV_SINT_VECTOR_MASK			0x00000000000000FFULL
#define IA32_MSR_HV_SINT_RSVD1_MASK				0x000000000000FF00ULL
#define IA32_MSR_HV_SINT_MASKED					0x0000000000010000ULL
#define IA32_MSR_HV_SINT_RSVD2_MASK				0xFFFFFFFFFFFC0000ULL
#define IA32_MSR_HV_SINT_RSVD_MASK \
	(IA32_MSR_HV_SINT_RSVD1_MASK | IA32_MSR_HV_SINT_RSVD2_MASK)

enum { // Hyper-V message types
	HYPERV_MSGTYPE_NONE				= 0x00000000,
	HYPERV_MSGTYPE_CHANNEL			= 0x00000001,
	HYPERV_MSGTYPE_TIMER_EXPIRED	= 0x80000010
};

enum { // Hypercall status
	HYPERCALL_STATUS_SUCCESS						= 0x0000,
	HYPERCALL_STATUS_INVALID_HYPERCALL_CODE			= 0x0002,
	HYPERCALL_STATUS_INVALID_HYPERCALL_INPUT		= 0x0003,
	HYPERCALL_STATUS_INVALID_ALIGNMENT				= 0x0004,
	HYPERCALL_STATUS_INVALID_PARAMETER				= 0x0005,
	HYPERCALL_STATUS_ACCESS_DENIED					= 0x0006,
	HYPERCALL_STATUS_INVALID_PARTITION_STATE		= 0x0007,
	HYPERCALL_STATUS_OPERATION_DENIED				= 0x0008,
	HYPERCALL_STATUS_UNKNOWN_PROPERTY				= 0x0009,
	HYPERCALL_STATUS_PROPERTY_VALUE_OUT_OF_RANGE	= 0x000A,
	HYPERCALL_STATUS_INSUFFICIENT_MEMORY			= 0x000B,
	HYPERCALL_STATUS_PARTITION_TOO_DEEP				= 0x000C,
	HYPERCALL_STATUS_INVALID_PARTITION_ID			= 0x000D,
	HYPERCALL_STATUS_INVALID_VP_INDEX				= 0x000E,
	HYPERCALL_STATUS_INVALID_PORT_ID				= 0x0011,
	HYPERCALL_STATUS_INVALID_CONNECTION_ID			= 0x0012,
	HYPERCALL_STATUS_INSUFFICIENT_BUFFERS			= 0x0013,
	HYPERCALL_STATUS_NOT_ACKNOWLEDGED				= 0x0014,
	HYPERCALL_STATUS_ACKNOWLEDGED					= 0x0016,
	HYPERCALL_STATUS_INVALID_SAVE_RESTORE_STATE		= 0x0017,
	HYPERCALL_STATUS_INVALID_SYNIC_STATE			= 0x0018,
	HYPERCALL_STATUS_OBJECT_IN_USE					= 0x0019,
	HYPERCALL_STATUS_INVALID_PROXIMITY_DOMAIN_INFO	= 0x001A,
	HYPERCALL_STATUS_NO_DATA						= 0x001B,
	HYPERCALL_STATUS_INACTIVE						= 0x001C,
	HYPERCALL_STATUS_NO_RESOURCES					= 0x001D,
	HYPERCALL_STATUS_FEATURE_UNAVAILABLE			= 0x001E,
	HYPERCALL_STATUS_PARTIAL_PACKET					= 0x001F
};

// Slow memory-based hypercall for VMBus messaging
#define HYPERCALL_POST_MESSAGE			0x0005C
// Fast register-based hypercall for VMBus events
#define HYPERCALL_SIGNAL_EVENT			0x1005D

// Maximum size for a hypercall message
#define HYPERCALL_MAX_DATA_SIZE			240
#define HYPERCALL_MAX_SIZE				256
// Maximum hypercall retry count
#define HYPERCALL_MAX_RETRY_COUNT		20

// Hypercall post message input parameters
// https://learn.microsoft.com/en-us/virtualization/hyper-v-on-windows/tlfs/hypercalls/hvcallpostmessage
typedef struct {
	uint32	connection_id;
	uint32	reserved;
	uint32	message_type;
	uint32	data_size;
	uint8	data[HYPERCALL_MAX_DATA_SIZE];
} _PACKED hypercall_post_msg_input;

#define HYPERV_SYNIC_MAX_INTS		16

#define HV_MESSAGE_FLAGS_PENDING	(1 << 0)

// SynIC message page
// https://learn.microsoft.com/en-us/virtualization/hyper-v-on-windows/tlfs/inter-partition-communication#sim-page

// Size of SynIC message data
#define HV_MESSAGE_DATA_SIZE		240
#define HV_MESSAGE_SIZE 			256

typedef struct { // Per-interrupt message data
	uint32	message_type;
	uint8	payload_size;
	uint8	message_flags;
	uint16	reserved1;
	union {
		uint64	origination_id;
		struct {
			uint32	port_id 	: 24;
			uint32	reserved2 	: 8;
		};
	};

	uint8	data[HV_MESSAGE_DATA_SIZE];
} _PACKED hv_message;

typedef struct { // All interrupts message data
	hv_message	interrupts[HYPERV_SYNIC_MAX_INTS];
} _PACKED hv_message_page;

// SynIC event flags
// https://learn.microsoft.com/en-us/virtualization/hyper-v-on-windows/tlfs/inter-partition-communication#synic-event-flags

// Size of SynIC event flags data
#define HV_EVENT_FLAGS_SIZE		256
#define HV_EVENT_FLAGS_COUNT	(HV_EVENT_FLAGS_SIZE * 8)

typedef struct { // Per-interrupt event flags
	uint8	flags[HV_EVENT_FLAGS_SIZE];
} _PACKED hv_event_flags;

typedef struct { // All interrupts event flags
	hv_event_flags	interrupts[HYPERV_SYNIC_MAX_INTS];
} _PACKED hv_event_flags_page;

// Haiku-specific version info
#define HYPERV_HAIKU_BUILD		0ULL
#define HYPERV_HAIKU_VERSION	((uint64)B_HAIKU_VERSION)
#define HYPERV_HAIKU_OSID		0ULL

#define IA32_MSR_HV_GUEST_OS_ID_BUILD_HAIKU		\
	(HYPERV_HAIKU_BUILD & IA32_MSR_HV_GUEST_OS_ID_BUILD_MASK)
#define IA32_MSR_HV_GUEST_OS_ID_VERSION_HAIKU	\
	((HYPERV_HAIKU_VERSION << IA32_MSR_HV_GUEST_OS_ID_VERSION_SHIFT) & \
		IA32_MSR_HV_GUEST_OS_ID_VERSION_MASK)
#define IA32_MSR_HV_GUEST_OS_ID_OSID_HAIKU		\
	((HYPERV_HAIKU_OSID << IA32_MSR_HV_GUEST_OS_ID_OSID_SHIFT) & \
		IA32_MSR_HV_GUEST_OS_ID_OSID_MASK)

#define IA32_MSR_HV_GUEST_OS_ID_HAIKU		\
	(IA32_MSR_HV_GUEST_OS_ID_BUILD_HAIKU	\
	| IA32_MSR_HV_GUEST_OS_ID_VERSION_HAIKU	\
	| IA32_MSR_HV_GUEST_OS_ID_OSID_HAIKU	\
	| IA32_MSR_HV_GUEST_OS_ID_OSTYPE_HAIKU)

#endif // _HYPERV_REG_H_
